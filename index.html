<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1e3a5f">
  <meta name="description" content="Dam Safety Inspection App - Section 3 On-Site Inspection">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Dam Inspect">
  <title>Dam Safety Inspection</title>
  
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  
  <!-- Local library files for offline support -->
  <script src="./react.min.js"></script>
  <script src="./react-dom.min.js"></script>
  <script src="./babel.min.js"></script>
  <script src="./jszip.min.js"></script>
  
  <style>
    /* Reset and base */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body, #root { height: 100%; margin: 0; overflow: hidden; font-family: system-ui, -apple-system, sans-serif; }
    textarea { resize: none; -webkit-appearance: none; -webkit-user-select: text; user-select: text; }
    button { cursor: pointer; border: none; }
    
    /* Photo grid */
    .photo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 8px; }
    .photo-thumb { aspect-ratio: 1; object-fit: cover; border-radius: 8px; cursor: pointer; }
    
    /* Layout */
    .flex { display: flex; }
    .flex-1 { flex: 1 1 0%; }
    .flex-col { flex-direction: column; }
    .flex-shrink-0 { flex-shrink: 0; }
    .block { display: block; }
    .hidden { display: none; }
    .items-center { align-items: center; }
    .justify-center { justify-content: center; }
    .justify-between { justify-content: space-between; }
    .gap-1 { gap: 0.25rem; }
    .gap-2 { gap: 0.5rem; }
    .gap-3 { gap: 0.75rem; }
    .space-y-1 > * + * { margin-top: 0.25rem; }
    .space-y-2 > * + * { margin-top: 0.5rem; }
    
    /* Sizing */
    .w-3 { width: 0.75rem; }
    .w-4 { width: 1rem; }
    .w-5 { width: 1.25rem; }
    .w-6 { width: 1.5rem; }
    .w-8 { width: 2rem; }
    .w-12 { width: 3rem; }
    .w-16 { width: 4rem; }
    .w-72 { width: 18rem; }
    .w-full { width: 100%; }
    .h-3 { height: 0.75rem; }
    .h-4 { height: 1rem; }
    .h-5 { height: 1.25rem; }
    .h-6 { height: 1.5rem; }
    .h-8 { height: 2rem; }
    .h-12 { height: 3rem; }
    .h-16 { height: 4rem; }
    .h-32 { height: 8rem; }
    .h-40 { height: 10rem; }
    .h-full { height: 100%; }
    .h-screen { height: 100vh; }
    .min-h-screen { min-height: 100vh; }
    .max-w-md { max-width: 28rem; }
    .max-w-2xl { max-width: 42rem; }
    .max-w-full { max-width: 100%; }
    .max-h-full { max-height: 100%; }
    .max-h-\\[60vh\\] { max-height: 60vh; }
    .max-h-\\[80vh\\] { max-height: 80vh; }
    
    /* Spacing */
    .p-1 { padding: 0.25rem; }
    .p-2 { padding: 0.5rem; }
    .p-3 { padding: 0.75rem; }
    .p-4 { padding: 1rem; }
    .p-6 { padding: 1.5rem; }
    .px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .pb-3 { padding-bottom: 0.75rem; }
    .mb-1 { margin-bottom: 0.25rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-5 { margin-bottom: 1.25rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .-mx-3 { margin-left: -0.75rem; margin-right: -0.75rem; }
    
    /* Colors */
    .bg-white { background-color: #fff; }
    .bg-black { background-color: #000; }
    .bg-gray-50 { background-color: #f9fafb; }
    .bg-gray-100 { background-color: #f3f4f6; }
    .bg-gray-200 { background-color: #e5e7eb; }
    .bg-gray-600 { background-color: #4b5563; }
    .bg-gray-700 { background-color: #374151; }
    .bg-blue-600 { background-color: #2563eb; }
    .bg-blue-800 { background-color: #1e40af; }
    .bg-blue-900 { background-color: #1e3a5f; }
    .bg-green-50 { background-color: #f0fdf4; }
    .bg-green-600 { background-color: #16a34a; }
    .bg-red-600 { background-color: #dc2626; }
    .bg-purple-500 { background-color: #a855f7; }
    .bg-purple-600 { background-color: #9333ea; }
    .bg-orange-600 { background-color: #ea580c; }
    .bg-teal-600 { background-color: #0d9488; }
    .bg-amber-500 { background-color: #f59e0b; }
    .bg-opacity-50 { background-color: rgba(0,0,0,0.5); }
    .bg-opacity-70 { background-color: rgba(0,0,0,0.7); }
    .bg-opacity-90 { background-color: rgba(0,0,0,0.9); }
    .text-white { color: #fff; }
    .text-gray-400 { color: #9ca3af; }
    .text-gray-500 { color: #6b7280; }
    .text-gray-600 { color: #4b5563; }
    .text-gray-700 { color: #374151; }
    .text-green-300 { color: #86efac; }
    .text-green-700 { color: #15803d; }
    .text-blue-300 { color: #93c5fd; }
    .text-amber-300 { color: #fcd34d; }
    .text-red-600 { color: #dc2626; }
    
    /* Borders */
    .border { border: 1px solid #e5e7eb; }
    .border-b { border-bottom: 1px solid #e5e7eb; }
    .border-t { border-top: 1px solid #e5e7eb; }
    .border-b-2 { border-bottom: 2px solid; }
    .border-gray-200 { border-color: #e5e7eb; }
    .border-gray-300 { border-color: #d1d5db; }
    .border-blue-900 { border-color: #1e3a5f; }
    .rounded { border-radius: 0.25rem; }
    .rounded-lg { border-radius: 0.5rem; }
    .rounded-xl { border-radius: 0.75rem; }
    .rounded-t-xl { border-top-left-radius: 0.75rem; border-top-right-radius: 0.75rem; }
    .rounded-full { border-radius: 9999px; }
    
    /* Typography */
    .text-xs { font-size: 0.75rem; line-height: 1rem; }
    .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
    .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
    .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .italic { font-style: italic; }
    .uppercase { text-transform: uppercase; }
    .text-center { text-align: center; }
    .text-left { text-align: left; }
    .truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    
    /* Position */
    .relative { position: relative; }
    .absolute { position: absolute; }
    .fixed { position: fixed; }
    .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
    .z-50 { z-index: 50; }
    
    /* Effects */
    .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04); }
    .opacity-50 { opacity: 0.5; }
    .overflow-hidden { overflow: hidden; }
    .overflow-x-auto { overflow-x: auto; }
    .overflow-y-auto { overflow-y: auto; }
    .object-cover { object-fit: cover; }
    .object-contain { object-fit: contain; }
    .cursor-pointer { cursor: pointer; }
    
    /* Animations */
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .animate-spin { animation: spin 1s linear infinite; }
    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    
    /* Focus states */
    .focus\\:outline-none:focus { outline: none; }
    .focus\\:ring-2:focus { box-shadow: 0 0 0 2px; }
    .focus\\:ring-blue-500:focus { box-shadow: 0 0 0 2px #3b82f6; }
    .focus\\:ring-green-500:focus { box-shadow: 0 0 0 2px #22c55e; }
    
    /* Hover states */
    .hover\\:bg-blue-700:hover { background-color: #1d4ed8; }
    .hover\\:bg-green-500:hover { background-color: #22c55e; }
    .hover\\:bg-red-50:hover { background-color: #fef2f2; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    /* =========================================================
       IndexedDB Storage Layer - supports up to 150MB+
       ========================================================= */
    class DamDB {
      constructor() {
        this.dbName = 'DamInspectionDB';
        this.version = 2; // Bumped for audios store
        this.db = null;
      }

      async open() {
        if (this.db) return this.db;
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.version);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('projects')) {
              db.createObjectStore('projects', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('inspections')) {
              db.createObjectStore('inspections', { keyPath: 'projectId' });
            }
            if (!db.objectStoreNames.contains('photos')) {
              const photoStore = db.createObjectStore('photos', { keyPath: 'id' });
              photoStore.createIndex('projectId', 'projectId', { unique: false });
              photoStore.createIndex('fieldKey', 'fieldKey', { unique: false });
            }
            if (!db.objectStoreNames.contains('audios')) {
              const audioStore = db.createObjectStore('audios', { keyPath: 'id' });
              audioStore.createIndex('projectId', 'projectId', { unique: false });
              audioStore.createIndex('fieldKey', 'fieldKey', { unique: false });
            }
            if (!db.objectStoreNames.contains('settings')) {
              db.createObjectStore('settings', { keyPath: 'key' });
            }
          };
          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve(this.db);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async getAll(storeName) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async get(storeName, key) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          const request = store.get(key);
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => reject(request.error);
        });
      }

      async put(storeName, data) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readwrite');
          const store = tx.objectStore(storeName);
          const request = store.put(data);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async delete(storeName, key) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readwrite');
          const store = tx.objectStore(storeName);
          const request = store.delete(key);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }

      async getByIndex(storeName, indexName, value) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          const index = store.index(indexName);
          const request = index.getAll(value);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async deleteByIndex(storeName, indexName, value) {
        const db = await this.open();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(storeName, 'readwrite');
          const store = tx.objectStore(storeName);
          const index = store.index(indexName);
          const request = index.openCursor(value);
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              cursor.delete();
              cursor.continue();
            } else {
              resolve();
            }
          };
          request.onerror = () => reject(request.error);
        });
      }

      async getStorageUsed() {
        try {
          if (navigator.storage && navigator.storage.estimate) {
            const est = await navigator.storage.estimate();
            return { used: est.usage || 0, quota: est.quota || 0 };
          }
        } catch(e) {}
        return { used: 0, quota: 0 };
      }
    }

    const db = new DamDB();

    /* =========================================================
       Photo compression utility
       ========================================================= */
    function compressPhoto(dataUrl, maxWidth = 1200, quality = 0.7) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          let w = img.width;
          let h = img.height;
          if (w > maxWidth) {
            h = Math.round(h * maxWidth / w);
            w = maxWidth;
          }
          const canvas = document.createElement('canvas');
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
      });
    }

    /* =========================================================
       SVG Icons
       ========================================================= */
    const Save = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>;
    const Download = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
    const Upload = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
    const Mic = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></svg>;
    const MicOff = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="2" y1="2" x2="22" y2="22"/><path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2"/><path d="M5 10v2a7 7 0 0 0 12 5"/><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12"/><line x1="12" y1="19" x2="12" y2="22"/></svg>;
    const Camera = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
    const Sparkles = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m12 3-1.9 5.8a2 2 0 0 1-1.3 1.3L3 12l5.8 1.9a2 2 0 0 1 1.3 1.3L12 21l1.9-5.8a2 2 0 0 1 1.3-1.3L21 12l-5.8-1.9a2 2 0 0 1-1.3-1.3L12 3Z"/></svg>;
    const X = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;
    const MenuIcon = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="18" x2="20" y2="18"/></svg>;
    const CheckCircle = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>;
    const AlertCircle = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>;
    const WifiIcon = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M5 13a10 10 0 0 1 14 0"/><path d="M8.5 16.5a5 5 0 0 1 7 0"/><path d="M2 8.82a15 15 0 0 1 20 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>;
    const WifiOff = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="2" y1="2" x2="22" y2="22"/><path d="M8.5 16.5a5 5 0 0 1 7 0"/><path d="M2 8.82a15 15 0 0 1 4.17-2.65"/><path d="M10.66 5c4.01-.36 8.14.9 11.34 3.76"/><path d="M16.85 11.25a10 10 0 0 1 2.22 1.68"/><path d="M5 13a10 10 0 0 1 5.24-2.76"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>;
    const Activity = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>;
    const Trash = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>;
    const Plus = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
    const ChevronDown = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="6 9 12 15 18 9"/></svg>;
    const FolderOpen = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"/></svg>;
    const HardDrive = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="22" y1="12" x2="2" y2="12"/><path d="M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/><line x1="6" y1="16" x2="6.01" y2="16"/><line x1="10" y1="16" x2="10.01" y2="16"/></svg>;

    const countWords = (text) => {
      if (!text || !text.trim()) return 0;
      return text.trim().split(/\s+/).length;
    };

    const getEmptyInspection = () => ({
      general: { access: '', routineReports: '', emergencyWarning: '', illumination: '', waterLevel: '', weatherConditions: '' },
      crest: { condition: '', vegetation: '', animalActivity: '', settlement: '' },
      upstream: { slopeProtection: '', condition: '', vegetation: '', animalBurrows: '' },
      downstream: { slopeProtection: '', condition: '', vegetation: '', seepage: '', animalActivity: '' },
      toe: { condition: '', erosion: '', seepage: '', vegetation: '', drainageSystem: '', valleyFloor: '' },
      spillway: { description: '', condition: '', vegetation: '', erosion: '' },
      outlet: { description: '', operation: '', condition: '', access: '', maintenance: '', seepage: '' },
      basin: { condition: '', erosion: '', seepage: '' },
      monitoring: { description: '', settlementMonitoring: '', seepageMonitoring: '' },
      crestSurvey: [{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]
    });

    /* =========================================================
       Main App Component
       ========================================================= */
    const Section3Inspection = () => {
      const [projects, setProjects] = useState([]);
      const [currentProjectId, setCurrentProjectId] = useState(null);
      const [showProjectModal, setShowProjectModal] = useState(false);
      const [showNewProjectModal, setShowNewProjectModal] = useState(false);
      const [newDamName, setNewDamName] = useState('');
      const [newInspectionDate, setNewInspectionDate] = useState(new Date().toISOString().split('T')[0]);
      
      const [activeTab, setActiveTab] = useState('general');
      const [status, setStatus] = useState('');
      const [loading, setLoading] = useState(true);
      const [isOnline, setIsOnline] = useState(navigator.onLine);
      const [showMenu, setShowMenu] = useState(false);
      const [aiProcessing, setAiProcessing] = useState(null);
      const [photoViewer, setPhotoViewer] = useState(null);
      const [storageUsed, setStorageUsed] = useState('');
      const importFileRef = useRef(null);
      const cameraInputRef = useRef(null);
      const [cameraTarget, setCameraTarget] = useState(null);
      const [pendingPhoto, setPendingPhoto] = useState(null); // {data, fieldKey, section, field}
      const [photoDescription, setPhotoDescription] = useState('');
      const [audioRecording, setAudioRecording] = useState(null); // {section, field}
      const [fieldAudios, setFieldAudios] = useState({});
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);
      
      const inspectionRef = useRef(getEmptyInspection());
      const [fieldPhotos, setFieldPhotos] = useState({});
      const [crestSurvey, setCrestSurvey] = useState([{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]);
      const [, forceUpdate] = useState(0);
      const MAX_STORAGE = 150 * 1024 * 1024; // 150MB

      useEffect(() => {
        initApp();
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      const updateStorageInfo = async () => {
        const info = await db.getStorageUsed();
        if (info.used > 0) {
          const usedMB = (info.used / 1024 / 1024).toFixed(1);
          setStorageUsed(`${usedMB} MB / 150 MB`);
        }
      };

      const initApp = async () => {
        setLoading(true);
        try {
          await db.open();
          const allProjects = await db.getAll('projects');
          allProjects.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
          setProjects(allProjects);

          const settings = await db.get('settings', 'lastActiveProject');
          const lastId = settings?.value;
          
          if (lastId && allProjects.find(p => p.id === lastId)) {
            await loadProject(lastId, allProjects);
          } else if (allProjects.length > 0) {
            await loadProject(allProjects[0].id, allProjects);
          }
          await updateStorageInfo();
        } catch (error) {
          console.error('Init error:', error);
          setStatus('Error initializing database');
        }
        setLoading(false);
      };

      const loadProject = async (projectId) => {
        try {
          const inspData = await db.get('inspections', projectId);
          if (inspData) {
            inspectionRef.current = { ...getEmptyInspection(), ...inspData.data };
            setCrestSurvey(inspData.data?.crestSurvey || [{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]);
          } else {
            inspectionRef.current = getEmptyInspection();
            setCrestSurvey([{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]);
          }

          // Load photo references for this project
          const projectPhotos = await db.getByIndex('photos', 'projectId', projectId);
          const photoMap = {};
          projectPhotos.forEach(p => {
            if (!photoMap[p.fieldKey]) photoMap[p.fieldKey] = [];
            photoMap[p.fieldKey].push(p);
          });
          setFieldPhotos(photoMap);

          // Load audio references for this project
          try {
            const projectAudios = await db.getByIndex('audios', 'projectId', projectId);
            const audioMap = {};
            projectAudios.forEach(a => {
              if (!audioMap[a.fieldKey]) audioMap[a.fieldKey] = [];
              audioMap[a.fieldKey].push(a);
            });
            setFieldAudios(audioMap);
          } catch (e) {
            // Audios store might not exist yet
            setFieldAudios({});
          }

          setCurrentProjectId(projectId);
          await db.put('settings', { key: 'lastActiveProject', value: projectId });
          forceUpdate(n => n + 1);
        } catch (error) {
          console.error('Load project error:', error);
        }
      };

      const saveCurrentProject = async () => {
        if (!currentProjectId) return;
        setStatus('Saving...');
        try {
          // Check storage limit
          const info = await db.getStorageUsed();
          if (info.used > MAX_STORAGE) {
            setStatus('âš ï¸ Storage limit reached (150MB)! Export and delete old inspections.');
            setTimeout(() => setStatus(''), 5000);
            return;
          }

          await db.put('inspections', {
            projectId: currentProjectId,
            data: { ...inspectionRef.current, crestSurvey }
          });

          // Update project timestamp
          const project = projects.find(p => p.id === currentProjectId);
          if (project) {
            const updated = { ...project, lastModified: new Date().toISOString() };
            await db.put('projects', updated);
            setProjects(prev => prev.map(p => p.id === currentProjectId ? updated : p));
          }

          await updateStorageInfo();
          setStatus('âœ“ Saved!');
        } catch (error) {
          console.error('Save error:', error);
          setStatus('Error saving');
        }
        setTimeout(() => setStatus(''), 2000);
      };

      const createNewProject = async () => {
        if (!newDamName.trim()) {
          setStatus('Enter a dam name');
          setTimeout(() => setStatus(''), 2000);
          return;
        }

        if (currentProjectId) await saveCurrentProject();

        const newProject = {
          id: `project-${Date.now()}`,
          damName: newDamName.trim(),
          inspectionDate: newInspectionDate,
          createdAt: new Date().toISOString(),
          lastModified: new Date().toISOString()
        };

        try {
          await db.put('projects', newProject);
          await db.put('inspections', { projectId: newProject.id, data: getEmptyInspection() });
          
          setProjects(prev => [newProject, ...prev]);
          inspectionRef.current = getEmptyInspection();
          setFieldPhotos({});
          setCrestSurvey([{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]);
          setCurrentProjectId(newProject.id);
          await db.put('settings', { key: 'lastActiveProject', value: newProject.id });
          
          setNewDamName('');
          setNewInspectionDate(new Date().toISOString().split('T')[0]);
          setShowNewProjectModal(false);
          forceUpdate(n => n + 1);
          setStatus(`âœ“ Created: ${newProject.damName}`);
        } catch (error) {
          setStatus('Error creating project');
        }
        setTimeout(() => setStatus(''), 2000);
      };

      const switchProject = async (projectId) => {
        if (projectId === currentProjectId) {
          setShowProjectModal(false);
          return;
        }
        if (currentProjectId) await saveCurrentProject();
        await loadProject(projectId);
        setShowProjectModal(false);
        const project = projects.find(p => p.id === projectId);
        setStatus(`âœ“ Loaded: ${project?.damName || ''}`);
        setTimeout(() => setStatus(''), 2000);
      };

      const deleteProject = async (projectId) => {
        const project = projects.find(p => p.id === projectId);
        if (!project) return;
        if (!confirm(`Delete "${project.damName}"?\n\nThis cannot be undone.`)) return;

        try {
          await db.delete('projects', projectId);
          await db.delete('inspections', projectId);
          await db.deleteByIndex('photos', 'projectId', projectId);

          const updatedProjects = projects.filter(p => p.id !== projectId);
          setProjects(updatedProjects);

          if (projectId === currentProjectId) {
            if (updatedProjects.length > 0) {
              await loadProject(updatedProjects[0].id);
            } else {
              setCurrentProjectId(null);
              inspectionRef.current = getEmptyInspection();
              setFieldPhotos({});
              setCrestSurvey([{ chainage: '0', level: '', freeboard: '', comment: 'Left Flank' }]);
              forceUpdate(n => n + 1);
            }
          }
          await updateStorageInfo();
          setStatus('âœ“ Deleted');
        } catch (error) {
          setStatus('Error deleting');
        }
        setTimeout(() => setStatus(''), 2000);
      };

      const getCurrentProject = () => projects.find(p => p.id === currentProjectId);

      // Photo handling with IndexedDB
      const openCamera = (section, field) => {
        setCameraTarget({ section, field });
        cameraInputRef.current?.click();
      };

      const handlePhotoCapture = async (e) => {
        const file = e.target.files[0];
        if (!file || !cameraTarget) return;

        setStatus('ðŸ“· Saving original & compressing...');

        // 1. Save ORIGINAL full-resolution photo to Downloads folder
        try {
          const project = getCurrentProject();
          const damLabel = (project?.damName || 'Dam').replace(/[^a-zA-Z0-9]/g, '_');
          const sectionLabel = cameraTarget.section;
          const fieldLabel = cameraTarget.field;
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const ext = (file.name?.split('.').pop() || 'jpg').toLowerCase();
          const origFilename = `${damLabel}_${sectionLabel}_${fieldLabel}_${timestamp}.${ext}`;
          
          const url = URL.createObjectURL(file);
          const a = document.createElement('a');
          a.href = url;
          a.download = origFilename;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 500);
        } catch (dlErr) {
          console.warn('Could not save original to Downloads:', dlErr);
        }

        // 2. Compress and prompt for description
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const compressed = await compressPhoto(event.target.result, 1200, 0.7);
            const fieldKey = `${cameraTarget.section}_${cameraTarget.field}`;
            
            // Store pending photo and show description dialog
            setPendingPhoto({
              data: compressed,
              fieldKey,
              section: cameraTarget.section,
              field: cameraTarget.field,
              timestamp: new Date().toISOString()
            });
            setPhotoDescription('');
            setStatus('');
          } catch (error) {
            console.error('Photo compress error:', error);
            setStatus('Error processing photo');
            setTimeout(() => setStatus(''), 3000);
          }
        };
        reader.readAsDataURL(file);
        e.target.value = '';
        setCameraTarget(null);
      };

      // Save photo with description
      const savePhotoWithDescription = async () => {
        if (!pendingPhoto) return;
        
        try {
          const photoRecord = {
            id: `photo-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
            projectId: currentProjectId,
            fieldKey: pendingPhoto.fieldKey,
            data: pendingPhoto.data,
            description: photoDescription.trim() || 'No description',
            timestamp: pendingPhoto.timestamp
          };

          await db.put('photos', photoRecord);
          
          setFieldPhotos(prev => ({
            ...prev,
            [pendingPhoto.fieldKey]: [...(prev[pendingPhoto.fieldKey] || []), photoRecord]
          }));
          
          await updateStorageInfo();
          setStatus('âœ“ Photo saved with description');
          setPendingPhoto(null);
          setPhotoDescription('');
        } catch (error) {
          console.error('Photo save error:', error);
          setStatus('Error saving photo');
        }
        setTimeout(() => setStatus(''), 3000);
      };

      // Skip description (save with default)
      const skipPhotoDescription = async () => {
        if (!pendingPhoto) return;
        setPhotoDescription('');
        await savePhotoWithDescription();
      };

      const deletePhoto = async (photoId, fieldKey) => {
        try {
          await db.delete('photos', photoId);
          setFieldPhotos(prev => ({
            ...prev,
            [fieldKey]: (prev[fieldKey] || []).filter(p => p.id !== photoId)
          }));
          setPhotoViewer(null);
          await updateStorageInfo();
          setStatus('âœ“ Photo deleted');
          setTimeout(() => setStatus(''), 2000);
        } catch (error) {
          setStatus('Error deleting photo');
        }
      };

      const getPhotosForField = (section, field) => {
        return fieldPhotos[`${section}_${field}`] || [];
      };

      // AI Improve
      const improveTextWithAI = async (section, field, text) => {
        if (!text || !text.trim() || text.trim().length < 10) return text;
        if (!navigator.onLine) return text;

        setAiProcessing(`${section}_${field}`);
        setStatus('ðŸ¤– AI improving...');
        try {
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 500,
              messages: [{
                role: "user",
                content: `Improve this dam inspection note for a professional report. Fix grammar, spelling, punctuation. Ensure every sentence ends with a full stop. Ensure every sentence starts with a capital letter. Improve clarity and flow. Keep all technical details accurate. Return ONLY the improved text:\n\n${text}`
              }]
            })
          });
          const data = await response.json();
          const improved = data.content?.filter(i => i.type === "text").map(i => i.text).join("") || text;
          setStatus('âœ“ AI improved!');
          setTimeout(() => setStatus(''), 2000);
          return improved.trim();
        } catch (error) {
          setStatus('AI unavailable');
          setTimeout(() => setStatus(''), 2000);
          return text;
        } finally {
          setAiProcessing(null);
        }
      };

      // Capitalize first letter of a string
      const capitalize = (s) => s ? s.charAt(0).toUpperCase() + s.slice(1) : s;

      // Get audios for a specific field
      const getAudioForField = (section, field) => {
        return fieldAudios[`${section}_${field}`] || [];
      };

      // Audio Recording (works offline - uses MediaRecorder API)
      const startAudioRecording = async (section, field) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorderRef.current = new MediaRecorder(stream);
          audioChunksRef.current = [];
          
          mediaRecorderRef.current.ondataavailable = (e) => {
            if (e.data.size > 0) {
              audioChunksRef.current.push(e.data);
            }
          };
          
          mediaRecorderRef.current.onstop = async () => {
            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            const reader = new FileReader();
            reader.onloadend = async () => {
              const fieldKey = `${section}_${field}`;
              const audioRecord = {
                id: `audio-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                projectId: currentProjectId,
                fieldKey,
                data: reader.result,
                timestamp: new Date().toISOString()
              };
              
              await db.put('audios', audioRecord);
              setFieldAudios(prev => ({
                ...prev,
                [fieldKey]: [...(prev[fieldKey] || []), audioRecord]
              }));
              setStatus('âœ“ Audio saved! Transcribe when online.');
              setTimeout(() => setStatus(''), 3000);
            };
            reader.readAsDataURL(audioBlob);
            
            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());
          };
          
          mediaRecorderRef.current.start();
          setAudioRecording({ section, field });
          setStatus('ðŸŽ™ï¸ Recording audio...');
        } catch (err) {
          console.error('Audio recording error:', err);
          setStatus('Cannot access microphone');
          setTimeout(() => setStatus(''), 2000);
        }
      };

      const stopAudioRecording = () => {
        if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
          mediaRecorderRef.current.stop();
        }
        setAudioRecording(null);
      };

      // Transcribe audio using AI when online
      const transcribeAudio = async (audio, section, field) => {
        if (!navigator.onLine) {
          setStatus('Need internet to transcribe');
          setTimeout(() => setStatus(''), 2000);
          return;
        }
        
        setStatus('ðŸ¤– Transcribing audio...');
        try {
          // Convert audio to base64 for API
          const base64Audio = audio.data.split(',')[1];
          
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 1000,
              messages: [{
                role: "user",
                content: [
                  {
                    type: "text",
                    text: "Please transcribe this audio recording of a dam inspection note. Fix any grammar issues, ensure sentences start with capital letters and end with full stops. Return ONLY the transcribed and corrected text, nothing else."
                  },
                  {
                    type: "image",
                    source: {
                      type: "base64",
                      media_type: "audio/webm",
                      data: base64Audio
                    }
                  }
                ]
              }]
            })
          });
          const data = await response.json();
          const transcript = data.content?.filter(i => i.type === "text").map(i => i.text).join("") || '';
          
          if (transcript) {
            // Add to field
            let cur = inspectionRef.current[section][field] || '';
            if (cur) {
              cur = cur.trimEnd();
              if (!/[.!?]$/.test(cur)) cur += '.';
              cur += ' ';
            }
            inspectionRef.current[section][field] = cur + capitalize(transcript);
            forceUpdate(n => n + 1);
            
            // Delete the audio after successful transcription
            await deleteAudio(audio.id, section, field);
            setStatus('âœ“ Transcribed and added!');
          } else {
            setStatus('Could not transcribe audio');
          }
        } catch (err) {
          console.error('Transcription error:', err);
          setStatus('Transcription failed - audio kept');
        }
        setTimeout(() => setStatus(''), 3000);
      };

      const deleteAudio = async (audioId, section, field) => {
        try {
          await db.delete('audios', audioId);
          const fieldKey = `${section}_${field}`;
          setFieldAudios(prev => ({
            ...prev,
            [fieldKey]: (prev[fieldKey] || []).filter(a => a.id !== audioId)
          }));
        } catch (err) {
          console.error('Delete audio error:', err);
        }
      };

      // Survey
      const addSurveyPoint = () => setCrestSurvey(prev => [...prev, { chainage: '', level: '', freeboard: '', comment: '' }]);
      const updateSurveyPoint = (index, field, value) => {
        setCrestSurvey(prev => {
          const updated = [...prev];
          updated[index] = { ...updated[index], [field]: value };
          if (field === 'level' && value) {
            try {
              const mf = localStorage.getItem('dam-main-features');
              if (mf) {
                const fsl = parseFloat(JSON.parse(mf).fsl);
                if (!isNaN(fsl)) updated[index].freeboard = (parseFloat(value) - fsl).toFixed(2);
              }
            } catch(e) {}
          }
          return updated;
        });
      };
      const removeSurveyPoint = (index) => setCrestSurvey(prev => prev.filter((_, i) => i !== index));

      // Export with photos from IndexedDB
      const exportData = async () => {
        setStatus('Preparing export...');
        try {
          const project = getCurrentProject();
          const projectPhotos = await db.getByIndex('photos', 'projectId', currentProjectId);
          
          // Rebuild photos object for export
          const photosObj = {};
          projectPhotos.forEach(p => {
            if (!photosObj[p.fieldKey]) photosObj[p.fieldKey] = [];
            photosObj[p.fieldKey].push({ id: p.id, data: p.data, description: p.description || '', timestamp: p.timestamp });
          });

          const exportObj = {
            damName: project?.damName || 'Unknown',
            inspectionDate: project?.inspectionDate || '',
            inspection: { ...inspectionRef.current, crestSurvey, photos: photosObj },
            exportDate: new Date().toISOString()
          };

          const jsonStr = JSON.stringify(exportObj);
          const sizeMB = (jsonStr.length / 1024 / 1024).toFixed(1);
          
          const blob = new Blob([jsonStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `DamInspection_${project?.damName || 'Draft'}_${new Date().toISOString().split('T')[0]}.json`;
          a.click();
          URL.revokeObjectURL(url);
          setStatus(`âœ“ Exported! (${sizeMB} MB)`);
        } catch(error) {
          setStatus('Export error');
        }
        setTimeout(() => setStatus(''), 3000);
      };

      // Import - handles large files with progress feedback
      const handleImport = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const sizeMB = (file.size / 1024 / 1024).toFixed(1);
        if (file.size > MAX_STORAGE) {
          setStatus(`File too large (${sizeMB} MB). Maximum is 150 MB.`);
          setTimeout(() => setStatus(''), 4000);
          e.target.value = '';
          return;
        }

        setStatus(`Reading ${sizeMB} MB file...`);
        
        const reader = new FileReader();
        
        // Progress feedback for reading
        reader.onprogress = (evt) => {
          if (evt.lengthComputable) {
            const pct = Math.round((evt.loaded / evt.total) * 100);
            setStatus(`Reading file... ${pct}%`);
          }
        };
        
        reader.onload = async (event) => {
          try {
            setStatus('Parsing JSON (this may take a moment)...');
            
            // Use setTimeout to allow UI to update before parsing
            await new Promise(r => setTimeout(r, 100));
            
            let data;
            try {
              data = JSON.parse(event.target.result);
            } catch (parseErr) {
              setStatus('Error: Invalid JSON file');
              setTimeout(() => setStatus(''), 4000);
              return;
            }
            
            const inspection = data.inspection || data;
            const dmName = data.damName || 'Imported Dam';
            
            const newProject = {
              id: `project-${Date.now()}`,
              damName: dmName,
              inspectionDate: data.inspectionDate || new Date().toISOString().split('T')[0],
              createdAt: new Date().toISOString(),
              lastModified: new Date().toISOString()
            };

            setStatus('Saving project...');
            await db.put('projects', newProject);
            
            // Save inspection without photos
            const inspWithoutPhotos = { ...inspection };
            delete inspWithoutPhotos.photos;
            await db.put('inspections', { projectId: newProject.id, data: inspWithoutPhotos });

            // Save photos to IndexedDB with yields for UI responsiveness
            const importedPhotos = inspection.photos || {};
            const photoKeys = Object.keys(importedPhotos);
            let photoCount = 0;
            let totalPhotos = 0;
            
            // Count total photos
            for (const fieldKey of photoKeys) {
              const arr = importedPhotos[fieldKey];
              if (Array.isArray(arr)) totalPhotos += arr.length;
            }
            
            for (const fieldKey of photoKeys) {
              const photoArr = importedPhotos[fieldKey];
              if (!Array.isArray(photoArr)) continue;
              
              for (const photo of photoArr) {
                photoCount++;
                setStatus(`Saving photo ${photoCount} of ${totalPhotos}...`);
                
                // Yield to browser every 5 photos
                if (photoCount % 5 === 0) {
                  await new Promise(r => setTimeout(r, 0));
                }
                
                await db.put('photos', {
                  id: photo.id || `photo-${Date.now()}-${Math.random().toString(36).substr(2,5)}`,
                  projectId: newProject.id,
                  fieldKey,
                  data: photo.data,
                  description: photo.description || 'No description',
                  timestamp: photo.timestamp || new Date().toISOString()
                });
              }
            }

            setProjects(prev => [newProject, ...prev]);
            await loadProject(newProject.id);
            await updateStorageInfo();
            setStatus(`âœ“ Imported: ${dmName} (${photoCount} photos)`);
          } catch(error) {
            console.error('Import error:', error);
            setStatus('Error importing: ' + (error.message || 'Unknown error'));
          }
          setTimeout(() => setStatus(''), 5000);
        };
        
        reader.onerror = (err) => {
          console.error('File read error:', err);
          setStatus('Error reading file. Try the Recovery Tool for large files.');
          setTimeout(() => setStatus(''), 5000);
        };
        
        reader.readAsText(file);
        e.target.value = '';
      };

      const generateReport = () => {
        const project = getCurrentProject();
        const d = inspectionRef.current;
        const photoCount = Object.values(fieldPhotos).flat().length;
        const report = `DAM SAFETY INSPECTION REPORT\nSection 3: On-Site Inspection\nDam: ${project?.damName || 'Unknown'}\nInspection Date: ${project?.inspectionDate || ''}\nGenerated: ${new Date().toLocaleDateString()}\nPhotos: ${photoCount}\n${'='.repeat(40)}\n\n3.1 GENERAL\nAccess: ${d.general.access}\nRoutine Reports: ${d.general.routineReports}\nEmergency Warning: ${d.general.emergencyWarning}\nIllumination: ${d.general.illumination}\nWater Level: ${d.general.waterLevel}\nWeather: ${d.general.weatherConditions}\n\n3.2 NON-OVERSPILL CREST\nCondition: ${d.crest.condition}\nVegetation: ${d.crest.vegetation}\nAnimal Activity: ${d.crest.animalActivity}\nSettlement: ${d.crest.settlement}\n\n3.3 UPSTREAM FACE\nSlope Protection: ${d.upstream.slopeProtection}\nCondition: ${d.upstream.condition}\nVegetation: ${d.upstream.vegetation}\nAnimal Burrows: ${d.upstream.animalBurrows}\n\n3.4 DOWNSTREAM FACE\nSlope Protection: ${d.downstream.slopeProtection}\nCondition: ${d.downstream.condition}\nVegetation: ${d.downstream.vegetation}\nSeepage: ${d.downstream.seepage}\nAnimal Activity: ${d.downstream.animalActivity}\n\n3.5 DOWNSTREAM TOE\nCondition: ${d.toe.condition}\nErosion: ${d.toe.erosion}\nSeepage: ${d.toe.seepage}\nVegetation: ${d.toe.vegetation}\nDrainage: ${d.toe.drainageSystem}\nValley Floor: ${d.toe.valleyFloor}\n\n3.6 SPILLWAY\nDescription: ${d.spillway.description}\nCondition: ${d.spillway.condition}\nVegetation: ${d.spillway.vegetation}\nErosion: ${d.spillway.erosion}\n\n3.7 OUTLET WORKS\nDescription: ${d.outlet.description}\nOperation: ${d.outlet.operation}\nCondition: ${d.outlet.condition}\nAccess: ${d.outlet.access}\nMaintenance: ${d.outlet.maintenance}\nSeepage: ${d.outlet.seepage}\n\n3.8 RESERVOIR BASIN\nCondition: ${d.basin.condition}\nErosion: ${d.basin.erosion}\nSeepage: ${d.basin.seepage}\n\n3.9 MONITORING\nDescription: ${d.monitoring.description}\nSettlement: ${d.monitoring.settlementMonitoring}\nSeepage: ${d.monitoring.seepageMonitoring}\n\n3.9.1 CREST SURVEY\n${crestSurvey.map(p => `Ch ${p.chainage}m: RL ${p.level}m, FB ${p.freeboard}m - ${p.comment}`).join('\n')}`;
        const blob = new Blob([report], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Report_${project?.damName || 'Draft'}_${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      };

      // Section number mapping
      const sectionNumbers = {
        general: '3.1', crest: '3.2', upstream: '3.3', downstream: '3.4',
        toe: '3.5', spillway: '3.6', outlet: '3.7', basin: '3.8', monitoring: '3.9'
      };

      // Get photos for a section with proper numbering
      const getSectionPhotos = (sectionId) => {
        const sectionNum = sectionNumbers[sectionId] || sectionId;
        const allPhotos = [];
        Object.entries(fieldPhotos).forEach(([key, photos]) => {
          if (key.startsWith(sectionId + '_')) {
            photos.forEach(p => allPhotos.push(p));
          }
        });
        return allPhotos.map((photo, idx) => ({
          ...photo,
          caption: `Photo ${sectionNum}-${idx + 1}: ${photo.description || 'No description'}`
        }));
      };

      // Generate Word Document (.docx) with photos and proper heading styles
      const generateWordReport = async () => {
        setStatus('Creating Word document with photos...');
        const project = getCurrentProject();
        const d = inspectionRef.current;
        const esc = (s) => (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

        // Collect all photos for embedding
        const allPhotosToEmbed = [];
        Object.keys(sectionNumbers).forEach(sec => {
          getSectionPhotos(sec).forEach(p => allPhotosToEmbed.push({ ...p, section: sec }));
        });

        // Helper to create paragraph with style
        const para = (text, style = '') => {
          const styleTag = style ? `<w:pPr><w:pStyle w:val="${style}"/></w:pPr>` : '';
          return `<w:p>${styleTag}<w:r><w:t xml:space="preserve">${esc(text)}</w:t></w:r></w:p>`;
        };

        // Helper for field with label
        const field = (label, value) => para(`${label}: ${value || 'N/A'}`);

        // Helper to create image paragraph with caption
        const imageWithCaption = (rId, caption) => {
          return `<w:p><w:r><w:drawing><wp:inline xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"><wp:extent cx="4572000" cy="3429000"/><wp:docPr id="${rId}" name="Photo"/><a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:nvPicPr><pic:cNvPr id="${rId}" name="Photo"/><pic:cNvPicPr/></pic:nvPicPr><pic:blipFill><a:blip xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:embed="rId${rId + 10}"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill><pic:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="4572000" cy="3429000"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></pic:spPr></pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing></w:r></w:p><w:p><w:pPr><w:pStyle w:val="Caption"/></w:pPr><w:r><w:t xml:space="preserve">${esc(caption)}</w:t></w:r></w:p>`;
        };

        // Generate section content with photos
        const sectionContent = (sectionId, title, fields) => {
          const photos = getSectionPhotos(sectionId);
          let content = para(title, 'Heading2');
          fields.forEach(f => { content += field(f.label, f.value); });
          
          // Add photos for this section
          photos.forEach((photo, idx) => {
            const photoIdx = allPhotosToEmbed.findIndex(p => p.id === photo.id);
            if (photoIdx >= 0) {
              content += imageWithCaption(photoIdx + 1, photo.caption);
            }
          });
          content += para('');
          return content;
        };

        // Build document content
        let content = [
          para('DAM SAFETY INSPECTION REPORT', 'Title'),
          para('Section 3: On-Site Inspection', 'Heading1'),
          para(`Dam: ${project?.damName || 'Unknown'}`),
          para(`Inspection Date: ${project?.inspectionDate || ''}`),
          para(`Generated: ${new Date().toLocaleDateString()}`),
          para(`Total Photos: ${allPhotosToEmbed.length}`),
          para('')
        ].join('');

        content += sectionContent('general', '3.1 General', [
          { label: 'Access', value: d.general.access },
          { label: 'Routine Reports', value: d.general.routineReports },
          { label: 'Emergency Warning', value: d.general.emergencyWarning },
          { label: 'Illumination', value: d.general.illumination },
          { label: 'Water Level', value: d.general.waterLevel },
          { label: 'Weather Conditions', value: d.general.weatherConditions }
        ]);

        content += sectionContent('crest', '3.2 Non-Overspill Crest', [
          { label: 'Condition', value: d.crest.condition },
          { label: 'Vegetation', value: d.crest.vegetation },
          { label: 'Animal Activity', value: d.crest.animalActivity },
          { label: 'Settlement', value: d.crest.settlement }
        ]);

        content += sectionContent('upstream', '3.3 Upstream Face', [
          { label: 'Slope Protection', value: d.upstream.slopeProtection },
          { label: 'Condition', value: d.upstream.condition },
          { label: 'Vegetation', value: d.upstream.vegetation },
          { label: 'Animal Burrows', value: d.upstream.animalBurrows }
        ]);

        content += sectionContent('downstream', '3.4 Downstream Face', [
          { label: 'Slope Protection', value: d.downstream.slopeProtection },
          { label: 'Condition', value: d.downstream.condition },
          { label: 'Vegetation', value: d.downstream.vegetation },
          { label: 'Seepage', value: d.downstream.seepage },
          { label: 'Animal Activity', value: d.downstream.animalActivity }
        ]);

        content += sectionContent('toe', '3.5 Downstream Toe', [
          { label: 'Condition', value: d.toe.condition },
          { label: 'Erosion', value: d.toe.erosion },
          { label: 'Seepage', value: d.toe.seepage },
          { label: 'Vegetation', value: d.toe.vegetation },
          { label: 'Drainage System', value: d.toe.drainageSystem },
          { label: 'Valley Floor', value: d.toe.valleyFloor }
        ]);

        content += sectionContent('spillway', '3.6 Spillway', [
          { label: 'Description', value: d.spillway.description },
          { label: 'Condition', value: d.spillway.condition },
          { label: 'Vegetation', value: d.spillway.vegetation },
          { label: 'Erosion', value: d.spillway.erosion }
        ]);

        content += sectionContent('outlet', '3.7 Outlet Works', [
          { label: 'Description', value: d.outlet.description },
          { label: 'Operation', value: d.outlet.operation },
          { label: 'Condition', value: d.outlet.condition },
          { label: 'Access', value: d.outlet.access },
          { label: 'Maintenance', value: d.outlet.maintenance },
          { label: 'Seepage', value: d.outlet.seepage }
        ]);

        content += sectionContent('basin', '3.8 Reservoir Basin', [
          { label: 'Condition', value: d.basin.condition },
          { label: 'Erosion', value: d.basin.erosion },
          { label: 'Seepage', value: d.basin.seepage }
        ]);

        content += sectionContent('monitoring', '3.9 Monitoring', [
          { label: 'Description', value: d.monitoring.description },
          { label: 'Settlement Monitoring', value: d.monitoring.settlementMonitoring },
          { label: 'Seepage Monitoring', value: d.monitoring.seepageMonitoring }
        ]);

        content += para('3.9.1 Crest Survey', 'Heading2');
        crestSurvey.forEach(p => {
          content += para(`Chainage ${p.chainage}m: RL ${p.level}m, Freeboard ${p.freeboard}m - ${p.comment}`);
        });

        // OOXML Document structure
        const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
<w:body>${content}<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr></w:body>
</w:document>`;

        const stylesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:style w:type="paragraph" w:styleId="Title"><w:name w:val="Title"/><w:pPr><w:jc w:val="center"/><w:spacing w:after="240"/></w:pPr><w:rPr><w:b/><w:sz w:val="48"/></w:rPr></w:style>
<w:style w:type="paragraph" w:styleId="Heading1"><w:name w:val="Heading 1"/><w:pPr><w:spacing w:before="360" w:after="240"/><w:outlineLvl w:val="0"/></w:pPr><w:rPr><w:b/><w:sz w:val="36"/></w:rPr></w:style>
<w:style w:type="paragraph" w:styleId="Heading2"><w:name w:val="Heading 2"/><w:pPr><w:spacing w:before="240" w:after="120"/><w:outlineLvl w:val="1"/></w:pPr><w:rPr><w:b/><w:sz w:val="28"/></w:rPr></w:style>
<w:style w:type="paragraph" w:styleId="Caption"><w:name w:val="Caption"/><w:pPr><w:spacing w:before="60" w:after="120"/></w:pPr><w:rPr><w:i/><w:sz w:val="20"/></w:rPr></w:style>
</w:styles>`;

        // Build image relationships
        let imageRels = '';
        allPhotosToEmbed.forEach((photo, idx) => {
          imageRels += `<Relationship Id="rId${idx + 11}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/image${idx + 1}.jpg"/>`;
        });

        const contentTypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Default Extension="jpg" ContentType="image/jpeg"/>
<Default Extension="jpeg" ContentType="image/jpeg"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
<Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`;

        const relsXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`;

        const documentRelsXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>${imageRels}
</Relationships>`;

        try {
          const zip = new JSZip();
          zip.file('[Content_Types].xml', contentTypesXml);
          zip.file('_rels/.rels', relsXml);
          zip.file('word/document.xml', documentXml);
          zip.file('word/styles.xml', stylesXml);
          zip.file('word/_rels/document.xml.rels', documentRelsXml);

          // Add images to media folder
          for (let i = 0; i < allPhotosToEmbed.length; i++) {
            setStatus(`Adding photo ${i + 1} of ${allPhotosToEmbed.length}...`);
            const photo = allPhotosToEmbed[i];
            // Convert base64 to binary
            const base64Data = photo.data.replace(/^data:image\/\w+;base64,/, '');
            zip.file(`word/media/image${i + 1}.jpg`, base64Data, { base64: true });
          }

          setStatus('Generating Word file...');
          const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Report_${project?.damName || 'Draft'}_${new Date().toISOString().split('T')[0]}.docx`;
          a.click();
          URL.revokeObjectURL(url);
          setStatus(`âœ“ Word document exported with ${allPhotosToEmbed.length} photos!`);
        } catch (err) {
          console.error('Word export error:', err);
          setStatus('Error creating Word document');
        }
        setTimeout(() => setStatus(''), 3000);
      };

      // Generate ODT Document with photos
      const generateODTReport = async () => {
        setStatus('Creating ODT document with photos...');
        const project = getCurrentProject();
        const d = inspectionRef.current;
        const esc = (s) => (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

        // Collect all photos for embedding
        const allPhotosToEmbed = [];
        Object.keys(sectionNumbers).forEach(sec => {
          getSectionPhotos(sec).forEach(p => allPhotosToEmbed.push({ ...p, section: sec }));
        });

        const para = (text, style = 'Normal') => `<text:p text:style-name="${style}">${esc(text)}</text:p>`;
        const field = (label, value) => para(`${label}: ${value || 'N/A'}`);

        // Helper for image with caption in ODT format
        const imageWithCaption = (imgNum, caption) => {
          return `<text:p text:style-name="Normal"><draw:frame xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" draw:name="Image${imgNum}" text:anchor-type="paragraph" svg:width="5in" svg:height="3.75in" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"><draw:image xlink:href="Pictures/image${imgNum}.jpg" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/></draw:frame></text:p><text:p text:style-name="Caption">${esc(caption)}</text:p>`;
        };

        // Generate section content with photos
        const sectionContent = (sectionId, title, fields) => {
          const photos = getSectionPhotos(sectionId);
          let content = para(title, 'Heading2');
          fields.forEach(f => { content += field(f.label, f.value); });
          
          // Add photos for this section
          photos.forEach((photo, idx) => {
            const photoIdx = allPhotosToEmbed.findIndex(p => p.id === photo.id);
            if (photoIdx >= 0) {
              content += imageWithCaption(photoIdx + 1, photo.caption);
            }
          });
          content += para('');
          return content;
        };

        // Build document content
        let content = [
          para('DAM SAFETY INSPECTION REPORT', 'Title'),
          para('Section 3: On-Site Inspection', 'Heading1'),
          para(`Dam: ${project?.damName || 'Unknown'}`),
          para(`Inspection Date: ${project?.inspectionDate || ''}`),
          para(`Generated: ${new Date().toLocaleDateString()}`),
          para(`Total Photos: ${allPhotosToEmbed.length}`),
          para('')
        ].join('');

        content += sectionContent('general', '3.1 General', [
          { label: 'Access', value: d.general.access },
          { label: 'Routine Reports', value: d.general.routineReports },
          { label: 'Emergency Warning', value: d.general.emergencyWarning },
          { label: 'Illumination', value: d.general.illumination },
          { label: 'Water Level', value: d.general.waterLevel },
          { label: 'Weather Conditions', value: d.general.weatherConditions }
        ]);

        content += sectionContent('crest', '3.2 Non-Overspill Crest', [
          { label: 'Condition', value: d.crest.condition },
          { label: 'Vegetation', value: d.crest.vegetation },
          { label: 'Animal Activity', value: d.crest.animalActivity },
          { label: 'Settlement', value: d.crest.settlement }
        ]);

        content += sectionContent('upstream', '3.3 Upstream Face', [
          { label: 'Slope Protection', value: d.upstream.slopeProtection },
          { label: 'Condition', value: d.upstream.condition },
          { label: 'Vegetation', value: d.upstream.vegetation },
          { label: 'Animal Burrows', value: d.upstream.animalBurrows }
        ]);

        content += sectionContent('downstream', '3.4 Downstream Face', [
          { label: 'Slope Protection', value: d.downstream.slopeProtection },
          { label: 'Condition', value: d.downstream.condition },
          { label: 'Vegetation', value: d.downstream.vegetation },
          { label: 'Seepage', value: d.downstream.seepage },
          { label: 'Animal Activity', value: d.downstream.animalActivity }
        ]);

        content += sectionContent('toe', '3.5 Downstream Toe', [
          { label: 'Condition', value: d.toe.condition },
          { label: 'Erosion', value: d.toe.erosion },
          { label: 'Seepage', value: d.toe.seepage },
          { label: 'Vegetation', value: d.toe.vegetation },
          { label: 'Drainage System', value: d.toe.drainageSystem },
          { label: 'Valley Floor', value: d.toe.valleyFloor }
        ]);

        content += sectionContent('spillway', '3.6 Spillway', [
          { label: 'Description', value: d.spillway.description },
          { label: 'Condition', value: d.spillway.condition },
          { label: 'Vegetation', value: d.spillway.vegetation },
          { label: 'Erosion', value: d.spillway.erosion }
        ]);

        content += sectionContent('outlet', '3.7 Outlet Works', [
          { label: 'Description', value: d.outlet.description },
          { label: 'Operation', value: d.outlet.operation },
          { label: 'Condition', value: d.outlet.condition },
          { label: 'Access', value: d.outlet.access },
          { label: 'Maintenance', value: d.outlet.maintenance },
          { label: 'Seepage', value: d.outlet.seepage }
        ]);

        content += sectionContent('basin', '3.8 Reservoir Basin', [
          { label: 'Condition', value: d.basin.condition },
          { label: 'Erosion', value: d.basin.erosion },
          { label: 'Seepage', value: d.basin.seepage }
        ]);

        content += sectionContent('monitoring', '3.9 Monitoring', [
          { label: 'Description', value: d.monitoring.description },
          { label: 'Settlement Monitoring', value: d.monitoring.settlementMonitoring },
          { label: 'Seepage Monitoring', value: d.monitoring.seepageMonitoring }
        ]);

        content += para('3.9.1 Crest Survey', 'Heading2');
        crestSurvey.forEach(p => {
          content += para(`Chainage ${p.chainage}m: RL ${p.level}m, Freeboard ${p.freeboard}m - ${p.comment}`);
        });

        const contentXml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document-content xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" office:version="1.2">
<office:automatic-styles>
<style:style style:name="Title" style:family="paragraph"><style:paragraph-properties fo:text-align="center"/><style:text-properties fo:font-size="24pt" fo:font-weight="bold"/></style:style>
<style:style style:name="Heading1" style:family="paragraph"><style:paragraph-properties fo:margin-top="0.3in" fo:margin-bottom="0.15in"/><style:text-properties fo:font-size="18pt" fo:font-weight="bold"/></style:style>
<style:style style:name="Heading2" style:family="paragraph"><style:paragraph-properties fo:margin-top="0.2in" fo:margin-bottom="0.1in"/><style:text-properties fo:font-size="14pt" fo:font-weight="bold"/></style:style>
<style:style style:name="Normal" style:family="paragraph"><style:text-properties fo:font-size="11pt"/></style:style>
<style:style style:name="Caption" style:family="paragraph"><style:paragraph-properties fo:margin-top="0.05in" fo:margin-bottom="0.15in"/><style:text-properties fo:font-size="10pt" fo:font-style="italic"/></style:style>
</office:automatic-styles>
<office:body><office:text>${content}</office:text></office:body>
</office:document-content>`;

        // Build manifest with image entries
        let manifestEntries = `<manifest:file-entry manifest:full-path="/" manifest:media-type="application/vnd.oasis.opendocument.text"/>
<manifest:file-entry manifest:full-path="content.xml" manifest:media-type="text/xml"/>`;
        
        allPhotosToEmbed.forEach((photo, idx) => {
          manifestEntries += `\n<manifest:file-entry manifest:full-path="Pictures/image${idx + 1}.jpg" manifest:media-type="image/jpeg"/>`;
        });

        const manifestXml = `<?xml version="1.0" encoding="UTF-8"?>
<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0">
${manifestEntries}
</manifest:manifest>`;

        const mimetypeContent = 'application/vnd.oasis.opendocument.text';

        try {
          const zip = new JSZip();
          zip.file('mimetype', mimetypeContent, { compression: 'STORE' });
          zip.file('content.xml', contentXml);
          zip.file('META-INF/manifest.xml', manifestXml);

          // Add images to Pictures folder
          for (let i = 0; i < allPhotosToEmbed.length; i++) {
            setStatus(`Adding photo ${i + 1} of ${allPhotosToEmbed.length}...`);
            const photo = allPhotosToEmbed[i];
            const base64Data = photo.data.replace(/^data:image\/\w+;base64,/, '');
            zip.file(`Pictures/image${i + 1}.jpg`, base64Data, { base64: true });
          }

          setStatus('Generating ODT file...');
          const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/vnd.oasis.opendocument.text' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `Report_${project?.damName || 'Draft'}_${new Date().toISOString().split('T')[0]}.odt`;
          a.click();
          URL.revokeObjectURL(url);
          setStatus(`âœ“ ODT document exported with ${allPhotosToEmbed.length} photos!`);
        } catch (err) {
          console.error('ODT export error:', err);
          setStatus('Error creating ODT document');
        }
        setTimeout(() => setStatus(''), 3000);
      };

      const tabs = [
        { id: 'general', name: '3.1 General' },
        { id: 'crest', name: '3.2 Crest' },
        { id: 'upstream', name: '3.3 Upstream' },
        { id: 'downstream', name: '3.4 D/Stream' },
        { id: 'toe', name: '3.5 Toe' },
        { id: 'spillway', name: '3.6 Spillway' },
        { id: 'outlet', name: '3.7 Outlet' },
        { id: 'basin', name: '3.8 Basin' },
        { id: 'monitoring', name: '3.9 Monitor' },
        { id: 'survey', name: '3.9.1 Survey' }
      ];

      // Native textarea
      const NativeTextArea = ({ section, field, rows, placeholder }) => {
        const textareaRef = useRef(null);
        const initialValueRef = useRef('');
        const [wordCount, setWordCount] = useState(0);

        useEffect(() => {
          if (textareaRef.current) {
            const value = inspectionRef.current[section]?.[field] || '';
            textareaRef.current.value = value;
            initialValueRef.current = value;
            setWordCount(countWords(value));
          }
        }, [section, field, currentProjectId]);

        const handleInput = (e) => {
          const v = e.target.value;
          const w = countWords(v);
          if (w > 1000) {
            const t = v.split(/\s+/).slice(0, 1000).join(' ');
            e.target.value = t;
            inspectionRef.current[section][field] = t;
            setWordCount(1000);
          } else {
            inspectionRef.current[section][field] = v;
            setWordCount(w);
          }
        };

        const handleBlur = async () => {
          const cur = textareaRef.current?.value || '';
          if (cur !== initialValueRef.current && cur.trim().length >= 20 && navigator.onLine) {
            const improved = await improveTextWithAI(section, field, cur);
            if (improved && improved !== cur && textareaRef.current) {
              textareaRef.current.value = improved;
              inspectionRef.current[section][field] = improved;
              initialValueRef.current = improved;
              setWordCount(countWords(improved));
            }
          }
        };

        return (
          <div>
            <textarea ref={textareaRef} rows={rows} placeholder={placeholder}
              onInput={handleInput} onBlur={handleBlur}
              className="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none"
              style={{ fontSize: '16px' }}
            />
            <div className={`text-xs mt-1 text-right ${wordCount >= 1000 ? 'text-red-500' : 'text-gray-400'}`}>
              {wordCount} / 1000 words
            </div>
          </div>
        );
      };

      // Inspection Field
      const InspectionField = ({ label, section, field, rows = 3 }) => {
        const fPhotos = getPhotosForField(section, field);
        const isAi = aiProcessing === `${section}_${field}`;
        const isAudioRec = audioRecording?.section === section && audioRecording?.field === field;
        const sectionNum = sectionNumbers[section] || section;

        return (
          <div className="mb-5 bg-gray-50 rounded-lg p-3">
            <div className="flex justify-between items-center mb-2">
              <label className="text-sm font-semibold text-gray-700">{label}</label>
              <div className="flex gap-1">
                <button onClick={() => openCamera(section, field)} className="p-2 bg-blue-600 text-white rounded-lg" type="button"><Camera className="w-4 h-4" /></button>
                <button onClick={() => isAudioRec ? stopAudioRecording() : startAudioRecording(section, field)} className={`p-2 rounded-lg ${isAudioRec ? 'bg-red-600 animate-pulse' : 'bg-green-600'} text-white`} type="button">
                  {isAudioRec ? <MicOff className="w-4 h-4" /> : <Mic className="w-4 h-4" />}
                </button>
                {isAi && <div className="p-2 bg-purple-500 text-white rounded-lg"><Sparkles className="w-4 h-4 animate-spin" /></div>}
              </div>
            </div>
            <NativeTextArea section={section} field={field} rows={rows} placeholder={`Enter ${label.toLowerCase()} observations...`} />
            
            {/* Audio recordings for this field */}
            {getAudioForField(section, field).length > 0 && (
              <div className="mt-2 space-y-1">
                {getAudioForField(section, field).map((audio, idx) => (
                  <div key={audio.id} className="flex items-center gap-2 bg-green-50 p-2 rounded text-sm">
                    <span className="text-green-700">ðŸŽ™ï¸ Audio {idx + 1}</span>
                    <audio src={audio.data} controls className="h-8 flex-1" />
                    {navigator.onLine && (
                      <button onClick={() => transcribeAudio(audio, section, field)} className="px-2 py-1 bg-purple-600 text-white rounded text-xs">Transcribe</button>
                    )}
                    <button onClick={() => deleteAudio(audio.id, section, field)} className="p-1 text-red-600"><Trash className="w-4 h-4" /></button>
                  </div>
                ))}
              </div>
            )}
            
            {/* Photos with captions */}
            {fPhotos.length > 0 && (
              <div className="mt-2">
                <div className="space-y-2">
                  {fPhotos.map((photo, idx) => (
                    <div key={photo.id} className="bg-white rounded-lg overflow-hidden border border-gray-200">
                      <img src={photo.data} alt="Inspection" className="w-full h-32 object-cover cursor-pointer"
                        onClick={() => setPhotoViewer({ photo, fieldKey: `${section}_${field}` })}
                      />
                      <p className="text-xs text-gray-600 p-2 italic bg-gray-50">
                        <span className="font-semibold">Photo {sectionNum}-{idx + 1}:</span> {photo.description || 'No description'}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        );
      };

      if (loading) {
        return (<div className="min-h-screen bg-gray-100 flex items-center justify-center"><div className="text-center"><div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-900 mx-auto mb-4"></div><p className="text-gray-600">Loading...</p></div></div>);
      }

      const currentProject = getCurrentProject();

      return (
        <div className="h-screen flex flex-col bg-gray-100">
          <input ref={cameraInputRef} type="file" accept="image/*" capture="environment" onChange={handlePhotoCapture} className="hidden" />
          <input ref={importFileRef} type="file" accept=".json" onChange={handleImport} className="hidden" />

          {!isOnline && (
            <div className="bg-amber-500 text-white text-center py-1 text-xs flex items-center justify-center gap-1"><WifiOff className="w-3 h-3" /> Offline - Auto AI disabled</div>
          )}

          {/* Header */}
          <div className="bg-blue-900 text-white flex-shrink-0">
            <div className="p-3 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <button onClick={() => setShowMenu(!showMenu)} className="p-1" type="button"><MenuIcon className="w-6 h-6" /></button>
                <h1 className="text-lg font-bold">Dam Inspection</h1>
              </div>
              <div className="flex items-center gap-2">
                {isOnline ? <WifiIcon className="w-4 h-4 text-green-300" /> : <WifiOff className="w-4 h-4 text-amber-300" />}
              </div>
            </div>
            <div className="px-3 pb-3 flex gap-2">
              <button onClick={() => setShowProjectModal(true)} className="flex-1 bg-blue-800 hover:bg-blue-700 rounded-lg px-3 py-2 flex items-center justify-between" type="button">
                <div className="flex items-center gap-2 text-left">
                  <FolderOpen className="w-4 h-4" />
                  <div>
                    <div className="text-sm font-medium truncate" style={{maxWidth:'180px'}}>{currentProject?.damName || 'No project'}</div>
                    {currentProject?.inspectionDate && <div className="text-xs text-blue-300">{currentProject.inspectionDate}</div>}
                  </div>
                </div>
                <ChevronDown className="w-4 h-4" />
              </button>
              <button onClick={() => setShowNewProjectModal(true)} className="bg-green-600 hover:bg-green-500 rounded-lg px-3 py-2 flex items-center gap-1" type="button">
                <Plus className="w-4 h-4" /><span className="text-sm">New</span>
              </button>
            </div>
          </div>

          {/* Status */}
          {status && (
            <div className={`px-3 py-2 text-sm flex items-center gap-2 ${status.includes('âœ“') ? 'bg-green-100 text-green-800' : status.includes('ðŸŽ¤') ? 'bg-red-100 text-red-800' : status.includes('ðŸ¤–') ? 'bg-purple-100 text-purple-800' : status.includes('âš ') ? 'bg-amber-100 text-amber-800' : 'bg-blue-100 text-blue-800'}`}>
              {status.includes('âœ“') ? <CheckCircle className="w-4 h-4" /> : <AlertCircle className="w-4 h-4" />}
              {status}
            </div>
          )}

          {/* Project Selection Modal */}
          {showProjectModal && (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
              <div className="absolute inset-0 bg-black bg-opacity-50" onClick={() => setShowProjectModal(false)}></div>
              <div className="relative bg-white rounded-xl w-full max-w-md max-h-[80vh] overflow-hidden">
                <div className="bg-blue-900 text-white p-4 flex justify-between items-center">
                  <h2 className="font-bold">Select Inspection</h2>
                  <button onClick={() => setShowProjectModal(false)} type="button"><X className="w-5 h-5" /></button>
                </div>
                <div className="overflow-y-auto max-h-[60vh]">
                  {projects.length === 0 ? (
                    <div className="p-6 text-center text-gray-500"><FolderOpen className="w-12 h-12 mx-auto mb-2 opacity-50" /><p>No inspections yet</p></div>
                  ) : projects.map(project => (
                    <div key={project.id} className={`p-4 border-b flex items-center justify-between ${project.id === currentProjectId ? 'bg-blue-50' : ''}`}>
                      <button onClick={() => switchProject(project.id)} className="flex-1 text-left" type="button">
                        <div className="font-medium">{project.damName}</div>
                        <div className="text-xs text-gray-500">{project.inspectionDate} â€¢ {new Date(project.lastModified).toLocaleDateString()}</div>
                      </button>
                      <button onClick={() => deleteProject(project.id)} className="p-2 text-red-600 hover:bg-red-50 rounded" type="button"><Trash className="w-4 h-4" /></button>
                    </div>
                  ))}
                </div>
                {storageUsed && <div className="px-4 py-2 border-t text-xs text-gray-500 flex items-center gap-1"><HardDrive className="w-3 h-3" /> Storage: {storageUsed}</div>}
              </div>
            </div>
          )}

          {/* New Project Modal */}
          {showNewProjectModal && (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
              <div className="absolute inset-0 bg-black bg-opacity-50" onClick={() => setShowNewProjectModal(false)}></div>
              <div className="relative bg-white rounded-xl w-full max-w-md">
                <div className="bg-green-600 text-white p-4 flex justify-between items-center rounded-t-xl">
                  <h2 className="font-bold">New Inspection</h2>
                  <button onClick={() => setShowNewProjectModal(false)} type="button"><X className="w-5 h-5" /></button>
                </div>
                <div className="p-4">
                  <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1">Dam Name *</label>
                    <input type="text" value={newDamName} onChange={(e) => setNewDamName(e.target.value)} placeholder="Enter dam name" className="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-green-500" style={{ fontSize: '16px' }} />
                  </div>
                  <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1">Inspection Date</label>
                    <input type="date" value={newInspectionDate} onChange={(e) => setNewInspectionDate(e.target.value)} className="w-full px-3 py-2 border rounded-lg" style={{ fontSize: '16px' }} />
                  </div>
                  <button onClick={createNewProject} className="w-full py-3 bg-green-600 text-white rounded-lg font-medium" type="button">Create Inspection</button>
                </div>
              </div>
            </div>
          )}

          {/* Side Menu */}
          {showMenu && (
            <div className="fixed inset-0 z-50 flex">
              <div className="absolute inset-0 bg-black bg-opacity-50" onClick={() => setShowMenu(false)}></div>
              <div className="relative bg-white w-72 h-full shadow-xl overflow-y-auto">
                <div className="bg-blue-900 text-white p-4 flex justify-between items-center">
                  <h2 className="font-bold">Menu</h2>
                  <button onClick={() => setShowMenu(false)} type="button"><X className="w-5 h-5" /></button>
                </div>
                <div className="p-3">
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">Sections</p>
                  {tabs.map(tab => (
                    <button key={tab.id} onClick={() => { setActiveTab(tab.id); setShowMenu(false); }}
                      className={`w-full text-left px-3 py-2 rounded text-sm mb-1 ${activeTab === tab.id ? 'bg-blue-100 text-blue-900 font-medium' : 'hover:bg-gray-100'}`} type="button">
                      {tab.name}
                    </button>
                  ))}
                </div>
                <div className="border-t p-3">
                  <p className="text-xs font-semibold text-gray-500 uppercase mb-2">Actions</p>
                  <button onClick={() => { saveCurrentProject(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-green-600 text-white rounded text-sm" type="button"><Save className="w-4 h-4" />Save</button>
                  <button onClick={() => { exportData(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-blue-600 text-white rounded text-sm" type="button"><Download className="w-4 h-4" />Export JSON</button>
                  <button onClick={() => { generateReport(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-gray-600 text-white rounded text-sm" type="button"><Download className="w-4 h-4" />Export TXT</button>
                  <button onClick={() => { generateWordReport(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-blue-800 text-white rounded text-sm" type="button"><Download className="w-4 h-4" />Export Word (.docx)</button>
                  <button onClick={() => { generateODTReport(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-teal-600 text-white rounded text-sm" type="button"><Download className="w-4 h-4" />Export ODT</button>
                  <button onClick={() => { importFileRef.current?.click(); setShowMenu(false); }} className="w-full flex items-center gap-2 px-3 py-2 mb-1 bg-orange-600 text-white rounded text-sm" type="button"><Upload className="w-4 h-4" />Import</button>
                </div>
                <div className="border-t p-3 text-xs text-gray-500">
                  <p className="flex items-center gap-1"><HardDrive className="w-3 h-3" /> {storageUsed || 'Calculating...'}</p>
                  <p className="mt-1"><b>{projects.length}</b> inspection(s)</p>
                </div>
              </div>
            </div>
          )}

          {/* Photo Description Dialog */}
          {pendingPhoto && (
            <div className="fixed inset-0 z-50 bg-black bg-opacity-50 flex items-center justify-center p-4">
              <div className="bg-white rounded-xl w-full max-w-md shadow-xl">
                <div className="p-4 border-b">
                  <h3 className="text-lg font-bold">Add Photo Description</h3>
                  <p className="text-sm text-gray-600">Describe what this photo shows</p>
                </div>
                <div className="p-4">
                  <img src={pendingPhoto.data} alt="Preview" className="w-full h-40 object-cover rounded-lg mb-3" />
                  <textarea
                    value={photoDescription}
                    onChange={(e) => setPhotoDescription(e.target.value)}
                    placeholder="e.g., Crack on downstream face near spillway..."
                    className="w-full border rounded-lg p-3 text-sm"
                    rows={3}
                    autoFocus
                  />
                </div>
                <div className="flex gap-2 p-4 border-t">
                  <button onClick={skipPhotoDescription} className="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg" type="button">Skip</button>
                  <button onClick={savePhotoWithDescription} className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg font-medium" type="button">Save Photo</button>
                </div>
              </div>
            </div>
          )}

          {/* Photo Viewer */}
          {photoViewer && (
            <div className="fixed inset-0 z-50 bg-black bg-opacity-90 flex flex-col">
              <div className="flex justify-between items-center p-3 text-white">
                <span className="text-sm">{new Date(photoViewer.photo.timestamp).toLocaleString()}</span>
                <div className="flex gap-3">
                  <button onClick={() => deletePhoto(photoViewer.photo.id, photoViewer.fieldKey)} className="p-2 bg-red-600 rounded" type="button"><Trash className="w-5 h-5" /></button>
                  <button onClick={() => setPhotoViewer(null)} className="p-2 bg-gray-700 rounded" type="button"><X className="w-5 h-5" /></button>
                </div>
              </div>
              <div className="flex-1 flex items-center justify-center p-4">
                <img src={photoViewer.photo.data} alt="Inspection" className="max-w-full max-h-full object-contain" />
              </div>
              {photoViewer.photo.description && (
                <div className="p-3 bg-black bg-opacity-70 text-white text-center">
                  <p className="text-sm italic">{photoViewer.photo.description}</p>
                </div>
              )}
            </div>
          )}

          {/* No Project */}
          {!currentProject && (
            <div className="flex-1 flex items-center justify-center p-4">
              <div className="text-center">
                <FolderOpen className="w-16 h-16 mx-auto mb-4 text-gray-400" />
                <h2 className="text-xl font-bold text-gray-700 mb-2">No Inspection Selected</h2>
                <button onClick={() => setShowNewProjectModal(true)} className="px-6 py-3 bg-green-600 text-white rounded-lg font-medium flex items-center gap-2 mx-auto" type="button"><Plus className="w-5 h-5" /> New Inspection</button>
              </div>
            </div>
          )}

          {/* Main Content */}
          {currentProject && (
            <>
              <div className="bg-white border-b overflow-x-auto flex-shrink-0">
                <div className="flex px-2 py-1 gap-1" style={{minWidth:'max-content'}}>
                  {tabs.map(tab => (
                    <button key={tab.id} onClick={() => setActiveTab(tab.id)}
                      className={`px-3 py-2 rounded text-xs whitespace-nowrap ${activeTab === tab.id ? 'bg-blue-600 text-white' : 'bg-gray-100'}`} type="button">
                      {tab.name}
                    </button>
                  ))}
                </div>
              </div>

              <div className="flex-1 overflow-y-auto p-3">
                <div className="max-w-2xl mx-auto">
                  {activeTab === 'general' && (<div><h2 className="text-lg font-bold mb-3">3.1 General</h2>
                    <InspectionField label="Access" section="general" field="access" rows={2} />
                    <InspectionField label="Routine inspection reports" section="general" field="routineReports" rows={2} />
                    <InspectionField label="Emergency Warning" section="general" field="emergencyWarning" rows={2} />
                    <InspectionField label="Illumination" section="general" field="illumination" rows={2} />
                    <InspectionField label="Water level on day of inspection" section="general" field="waterLevel" rows={1} />
                    <InspectionField label="Weather conditions" section="general" field="weatherConditions" rows={2} />
                  </div>)}
                  {activeTab === 'crest' && (<div><h2 className="text-lg font-bold mb-3">3.2 Non-Overspill Crest</h2>
                    <InspectionField label="Condition of crest" section="crest" field="condition" />
                    <InspectionField label="Vegetation" section="crest" field="vegetation" />
                    <InspectionField label="Animal activity" section="crest" field="animalActivity" rows={2} />
                    <InspectionField label="Settlement" section="crest" field="settlement" />
                  </div>)}
                  {activeTab === 'upstream' && (<div><h2 className="text-lg font-bold mb-3">3.3 Upstream Face</h2>
                    <InspectionField label="Slope protection" section="upstream" field="slopeProtection" rows={2} />
                    <InspectionField label="Condition of face" section="upstream" field="condition" />
                    <InspectionField label="Vegetation" section="upstream" field="vegetation" />
                    <InspectionField label="Animal burrows" section="upstream" field="animalBurrows" rows={2} />
                  </div>)}
                  {activeTab === 'downstream' && (<div><h2 className="text-lg font-bold mb-3">3.4 Downstream Face</h2>
                    <InspectionField label="Slope protection" section="downstream" field="slopeProtection" rows={2} />
                    <InspectionField label="Condition of face" section="downstream" field="condition" />
                    <InspectionField label="Vegetation" section="downstream" field="vegetation" />
                    <InspectionField label="Seepage" section="downstream" field="seepage" rows={2} />
                    <InspectionField label="Animal activity" section="downstream" field="animalActivity" rows={2} />
                  </div>)}
                  {activeTab === 'toe' && (<div><h2 className="text-lg font-bold mb-3">3.5 Downstream Toe</h2>
                    <InspectionField label="Condition" section="toe" field="condition" rows={2} />
                    <InspectionField label="Erosion" section="toe" field="erosion" rows={2} />
                    <InspectionField label="Seepage" section="toe" field="seepage" rows={2} />
                    <InspectionField label="Vegetation" section="toe" field="vegetation" rows={2} />
                    <InspectionField label="Drainage system" section="toe" field="drainageSystem" />
                    <InspectionField label="Valley floor downstream of toe" section="toe" field="valleyFloor" rows={2} />
                  </div>)}
                  {activeTab === 'spillway' && (<div><h2 className="text-lg font-bold mb-3">3.6 Spillway</h2>
                    <InspectionField label="Description" section="spillway" field="description" />
                    <InspectionField label="Condition" section="spillway" field="condition" rows={4} />
                    <InspectionField label="Vegetation" section="spillway" field="vegetation" />
                    <InspectionField label="Erosion" section="spillway" field="erosion" rows={4} />
                  </div>)}
                  {activeTab === 'outlet' && (<div><h2 className="text-lg font-bold mb-3">3.7 Outlet Works</h2>
                    <InspectionField label="Description" section="outlet" field="description" rows={4} />
                    <InspectionField label="Operation of valves" section="outlet" field="operation" />
                    <InspectionField label="Condition" section="outlet" field="condition" />
                    <InspectionField label="Access to outlet works" section="outlet" field="access" rows={2} />
                    <InspectionField label="Maintenance and test procedure" section="outlet" field="maintenance" />
                    <InspectionField label="Seepage along outlet pipe" section="outlet" field="seepage" rows={2} />
                  </div>)}
                  {activeTab === 'basin' && (<div><h2 className="text-lg font-bold mb-3">3.8 Reservoir Basin</h2>
                    <InspectionField label="Condition" section="basin" field="condition" />
                    <InspectionField label="Erosion" section="basin" field="erosion" rows={2} />
                    <InspectionField label="Seepage through basin" section="basin" field="seepage" rows={2} />
                  </div>)}
                  {activeTab === 'monitoring' && (<div><h2 className="text-lg font-bold mb-3">3.9 Monitoring of Dam</h2>
                    <InspectionField label="Description" section="monitoring" field="description" />
                    <InspectionField label="Settlement monitoring" section="monitoring" field="settlementMonitoring" />
                    <InspectionField label="Seepage monitoring" section="monitoring" field="seepageMonitoring" />
                  </div>)}
                  {activeTab === 'survey' && (<div><h2 className="text-lg font-bold mb-3">3.9.1 Crest Survey</h2>
                    <p className="text-xs text-gray-600 mb-3">Freeboard auto-calculated from FSL</p>
                    <div className="overflow-x-auto -mx-3 px-3">
                      <table className="w-full border text-sm" style={{minWidth:'450px'}}>
                        <thead className="bg-gray-200"><tr>
                          <th className="border px-2 py-1">Ch (m)</th><th className="border px-2 py-1">R.L. (m)</th>
                          <th className="border px-2 py-1">FB (m)</th><th className="border px-2 py-1">Comment</th><th className="border px-2 py-1 w-8"></th>
                        </tr></thead>
                        <tbody>{crestSurvey.map((point, index) => (
                          <tr key={index}>
                            <td className="border p-1"><input type="text" defaultValue={point.chainage} onBlur={(e) => updateSurveyPoint(index, 'chainage', e.target.value)} className="w-full px-1 py-1 text-sm border rounded" style={{fontSize:'16px'}} /></td>
                            <td className="border p-1"><input type="text" defaultValue={point.level} onBlur={(e) => updateSurveyPoint(index, 'level', e.target.value)} className="w-full px-1 py-1 text-sm border rounded" style={{fontSize:'16px'}} /></td>
                            <td className="border p-1"><input type="text" value={point.freeboard} readOnly className="w-full px-1 py-1 text-sm bg-gray-100 rounded" /></td>
                            <td className="border p-1"><input type="text" defaultValue={point.comment} onBlur={(e) => updateSurveyPoint(index, 'comment', e.target.value)} className="w-full px-1 py-1 text-sm border rounded" style={{fontSize:'16px'}} /></td>
                            <td className="border p-1 text-center">{index > 0 && <button onClick={() => removeSurveyPoint(index)} className="text-red-600 font-bold" type="button">Ã—</button>}</td>
                          </tr>
                        ))}</tbody>
                      </table>
                    </div>
                    <button onClick={addSurveyPoint} className="mt-3 px-4 py-2 bg-blue-600 text-white rounded text-sm" type="button">+ Add Point</button>
                  </div>)}
                </div>
              </div>

              <div className="bg-white border-t p-2 flex gap-2 flex-shrink-0">
                <button onClick={saveCurrentProject} className="flex-1 py-3 bg-green-600 text-white rounded-lg font-medium flex items-center justify-center gap-2" type="button"><Save className="w-5 h-5" />Save</button>
                <button onClick={exportData} className="flex-1 py-3 bg-blue-600 text-white rounded-lg font-medium flex items-center justify-center gap-2" type="button"><Download className="w-5 h-5" />Export</button>
              </div>
            </>
          )}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<Section3Inspection />);
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(r => console.log('SW registered')).catch(e => console.log('SW failed:', e));
      });
    }
  </script>
</body>
</html>
